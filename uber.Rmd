---
title: "uber analysis"
author: "Krishnan Raman"
date: "10/6/2020"
output: pdf_document
---

```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
library("dplyr")
library(tidyverse)
library(lattice)

# CHANGE THIS TO LOCAL DRIVE WHERE uber_nyc_data.csv is located
# set nrows to 40 million
setwd("~/Desktop/695/uber-tlc-foil-response/uber-trip-data/")
df<-read.csv("uber_nyc_data.csv", nrows=1000*1000*40)

# convert factor vars to formatted numbers
df$distance = as.double(as.character(df$trip_distance))
df$duration = as.double(as.difftime(as.character(df$trip_duration), format = "%H:%M:%S", units = "mins"))

# find 1% & 99% quantiles, eliminate anything beyond
# this helps with cancelled trips, overly long trips & other weird outlier cases
durq = quantile(df$duration,c(0.01, 0.99), names=F, na.rm=T)
disq = quantile(df$distance,c(0.01, 0.99), names=F, na.rm=T)

df2 = df[df$duration > durq[1] & df$duration < durq[2] & df$distance > disq[1] & df$distance < disq[2],]
df2 = select(df2,2:4, 7:8)

# remove NAs & prev dataframes
final = df2[complete.cases(df2), ]
rm(df,df2)
```

compute fare based on linear combination of time and distance

```{r}

base_fare = 2.55
per_minute = 0.35
per_mile = 1.75
min_fare = 8
final$fare <- mapply(function(dis,dur) {
  max(min_fare, base_fare + per_minute*dur + per_mile*dis)
}, final$distance, final$duration)
# distance distribution, duration distribution
hist(final$distance)
hist(final$duration)
hist(final$fare)

# get summary stats
summary(final)
```
log transform for positive variates
```{r}
final$logdist = log(1.0+final$distance)
final$logdur = log(1.0 + final$duration)
final$logfare = log(final$fare)
```

gamma priors
```{r}
bestgammafit = function(x,title) {
dist_scale = var(x)/mean(x)
dist_shape = mean(x)/dist_scale
plot(density(x), main=title)
px=seq(0,5,0.05)
py=dgamma(px,scale=dist_scale, shape=dist_shape)
lines(px,py, col='red')
}

bestgammafit(final$logdist, "log distance")
bestgammafit(final$logdur, "log duration")
bestgammafit(final$logfare, "log fare")
```
Try exp ( Gamma(1)) & Pareto fits as well.
compute posterior from prior and likelihood
a-b-c-... circuit for highest fare, least distance

```{r}
# Number of intervals per hour for the time points

n_intvls <- 10
day_length <- 24
hour_length <- 60

# Read in first 1 million rows of data set

uber_orig <- read.csv("C://Users/david/Desktop/uber.csv", nrows = 1000*1000, stringsAsFactors = FALSE)
uber <- uber_orig

# Create a new variable with just the hour of pickup time

uber$origin_hour <- uber$pickup_datetime %>% str_split (" ") %>% lapply(function(x) x[2]) %>% unlist() %>% 
  substr(1,2) %>% as.numeric()

# Create another variable with minutes of trip

uber$trip_minutes <-  uber$trip_duration %>% str_split(":") %>% 
  lapply(function(x) hour_length*as.numeric(x[1])+as.numeric(x[2]) + 
           round(as.numeric(x[3])/hour_length)) %>% unlist()

# Create new variable with just the day

uber$trip_day <- as.Date(uber$pickup_datetime)

# Filter out some trips with missing data or excessive trip times
# Only selecting the first two weeks

uber2 <- uber %>% filter(!(trip_minutes <= 0 | is.na(trip_minutes) == TRUE | 
                            trip_minutes > 100) & trip_day >= "2014-09-01" & trip_day <= "2014-09-15")

# Names of stations 

station_names <- unique(uber$destination_taz)
station_names <- station_names[station_names!="NULL"]

# Reformat into a matrix with 96 quarter-hours for rows and locations as columns

lt_mat <- matrix(0, n_intvls*day_length, length(station_names)) %>% data.frame()
colnames(lt_mat) <- station_names

# Number of minutes for window length

window_length <- 2

# Get number of at the closest destination for every 6 minutes of the day
# Using a 2 minute window in either direction as definition of close

for (i in 1:nrow(lt_mat)){
  cur_time <- floor((i-1)/n_intvls)*hour_length + ((i-1) %% n_intvls)*hour_length/n_intvls
  cur_window <- c(max(0, cur_time-window_length), cur_time+window_length)
  
  cur_counts <- suppressMessages(uber2 %>% filter((origin_hour*hour_length + trip_minutes) >= cur_window[1] &
                   (origin_hour*hour_length + trip_minutes) <= cur_window[2] &
                     destination_taz != "NULL") %>% 
    group_by(destination_taz) %>% summarise(n_cars = n()))
    
  lt_mat[i,cur_counts$destination_taz] <- cur_counts$n_cars
}

# Reformat for plotting (still only plotting everything except 2A)

loc_times <- lt_mat %>% gather(station_names, num_cars)
loc_times$time <- rep(1:(n_intvls*day_length), times = length(station_names))
loc_times %>% filter(station_names != "2A") %>% 
  xyplot(num_cars ~ time | station_names, data = ., type = 'l')
```


